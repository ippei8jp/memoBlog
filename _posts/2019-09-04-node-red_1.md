---
title: Node-REDのHowTo
date: 2019-09-04
tags: ["Ubuntu","RaspberryPi","Node.js","Node-RED"]
excerpt: Node-REDのインストール他のメモ
layout: default
---



# ubuntu に Node-RED をインストールする。

## Node.jsとnpmのインストール

自動起動とかやらないなら、Node.js は nodenv とか使っても良い気がするが、
念のためシステムに直接インストールしておく。  

``apt install`` だと古いバージョンになってしまうので、  
nコマンド をインストールし、  
nコマンドで安定版をインストールする。  
その後、``apt`` でインストールしたNode.jsは削除。  

```bash
# インストール
sudo apt install nodejs-legacy npm

# バージョン確認
node -v

# nコマンドのインストール
sudo npm install -g n

# 安定版のインストール
sudo n stable

# aptでインストールしたnode.jsをアンインストール
sudo apt purge -y nodejs-legacy npm

# バージョン確認
node -v
```

## Node-REDのインストール

```bash
sudo npm install -g --unsafe-perm node-red node-red-admin
```

どうも、ノードの追加とかすると、npmのキャッシュをアクセスするときにpermission deniedと言われてしまうみたいなので、
以下のコマンドで .npm ディレクトリ以下の所有権を自分にしておく。  

```bash
sudo chown -R `whoami`:`whoami` ~/.npm
```

## 起動

```bash
node-red
```

ブラウザで http://対象IPアドレス:1880 に接続

## 参考

<https://qiita.com/seibe/items/36cef7df85fe2cefa3ea>  
<https://nodered.jp/docs/getting-started/local>



# Raspbian に Node-RED をインストールする。

## Node.js と npm と Node-RED のインストール

インストールスクリプトを実行すればイッパツで解決。  

```bash
# インストールスクリプトの取得
wget  https://raw.githubusercontent.com/node-red/raspbian-deb-package/master/resources/update-nodejs-and-nodered

# 必要なら中身確認してね

# インストールスクリプトの実行
bash update-nodejs-and-nodered 
```


## 起動

```bash
node-red-start 
```
CTRL-Cでログ表示のみ止まる(Node-RED自体は動作したまま)  

ブラウザで http://対象IPアドレス:1880 に接続  

## ログ表示

Node-RED で console.log などを実行したときは、ログに表示される。  
``node-red-start``したままなら表示されるが、CTRL-Cでログ表示を止めていた場合は
以下のコマンドでログ表示を再開できる。  

```bash
node-red-log
```

## 停止

Node-RED自体を停止する。  

```bash
node-red-stop
```


## 参考

<https://qiita.com/utaani/items/7155c62d6c5e96822afb>  
<https://nodered.jp/docs/getting-started/local>

# Node-REDで作成したフローを一時的に停止する方法

作成したフローを削除せずに一時的に停止したい場合の手順  

- フローエディタの上部のタブで、停止したいフローのタブをダブルクリック→ 編集メニューが表示される
    - 状態を「無効」にする
    - 完了をクリック
- デプロイする(デプロイしないといつまで経っても停止しないので注意)

再開する場合は上記手順と同じで、状態を「有効」にする。  

# Dashboardをインストールする

- ブラウザでNode-REDに接続した状態で、右上の3本線メニュー(≡) から「パレットの管理」をクリック
- 画面上部の「ノードを追加」をクリック
- ノードを検索の部分に「node-red-dashboard」と入力
- 下に検索結果が出るので。「node-red-dashboard」の「ノードを追加」をクリック
- 何やらダイアログが出るので、「追加」をクリック
- 完了したら「閉じる」をクリック。

# Dashboard のフローを作成する
- パレット(左側のペイン)の「dashboard」の下の「button」 をフローにドラッグ&ドロップ
- ドロップした「button」をダブルクリック → 編集メニューが表示される
    - Group で「新規に ui_group を追加...」を選択してその右の編集ボタンをクリック
        - 名前は適当に設定
        - タブ で「新規に ui_tab を追加...」を選択してその右の編集ボタンをクリック
            - 適当に値を設定する
            - 右上の「追加」をクリック
        - 右上の「追加」をクリック
    - Group に 今設定したグループとタブが選択されていることを確認
    - label で表示名を変更
    - Payload に クリックされたときに送信するデータを設定
    - 右上の「完了」をクリック

- 次段以降のノードを追加
- デプロイする

- ブラウザで、http://対象IPアドレス:1880/ui に接続
    - Dashboardが表示されるハズ
    - ボタンをクリックしたらフローが動作する。

# Dashboard のレイアウトを修正する

ボタンのサイズを小さくしたり、複数のボタンを横に並べたい場合はレイアウトの修正を行う。  

- サイドバー(右側のペイン)の「dashboard」ボタン(グラフのアイコン)をクリック
- 配置タブをクリック
- タブの部分(「ホーム」など)をマウスでポイントし、「レイアウト」をクリック
    - 表示領域の幅を変更するには、右上の「幅」の設定値を変更する。(単位はグリッド数)
    - 各要素をドラッグすると、表示位置を入れ替えられる。
    - 各要素のサイズを変更するには、
        - 右上の鍵アイコンをクリックして閉じた状態にする(鍵が開いた状態では表示領域幅に一致するように自動変更される)
        - 右下に矢印アイコンが表示されるので、これをつまんでサイズを変更
    - 各要素を横並びにしたい場合は、各要素をドラッグして移動する(表示幅に収まらない場合は移動できない)
    - 各要素のサイズ/位置はグリッド単位でのみ可能
    - 右上の完了をクリック
ｰ デプロイする

# サーバ側でWebsocketでデータを送信する

- パレットの「出力」の下の「websocket」 をフローにドラッグ&ドロップ
- ドロップした「websocket」をダブルクリック → 編集メニューが表示される
    - 種類で「待ち受け」を選択
    - パス で 「新規に websocket-listner を追加」を選択してその右の編集ボタンをクリック or 既に設定されているパスを選択
        - パス を適当に設定(/ws/data01 など)
            - Websocket の Listen port のポート番号は Node-RED のポート番号と同じになるので、Client側で指定するURLはそのポート番号を指定すること
        - 送信/受信で送受信するデータを選択
        - 追加をクリック
    - パス に 今設定したパスが表示されていることを確認
    - 必要なら名前を設定
    - 完了をクリック
- トリガとなるノードを接続
- デプロイする

# サーバ側でWebsocketでデータを受信する

- パレットの「入力」の下の「websocket」 をフローにドラッグ&ドロップ
- ドロップした「websocket」をダブルクリック → 編集メニューが表示される
    - 種類で「待ち受け」を選択
    - パス で 「新規に websocket-listner を追加」を選択してその右の編集ボタンをクリック or 既に設定されているパスを選択
        - パス を適当に設定(/ws/data01 など)
            - Websocket の Listen port のポート番号は Node-RED のポート番号と同じになるので、Client側で指定するURLはそのポート番号を指定すること
        - 送信/受信で送受信するデータを選択
        - 追加をクリック
    - パス に 今設定したパスが表示されていることを確認
    - 必要なら名前を設定
    - 完了をクリック
- 受信したメッセージを処理するノードを接続
- デプロイする

# クライアント側でWebsocketでデータを送信する

- パレットの「出力」の下の「websocket」 をフローにドラッグ&ドロップ
- ドロップした「websocket」をダブルクリック → 編集メニューが表示される
    - 種類 で「接続」を選択
    - URL で 「新規に websocket-client を追加」を選択してその右の編集ボタンをクリック or 既に設定されているサーバを選択
        - URL でサーバのURLを設定(例： ws://PiDev25.local:1880/ws/data01)
        - 追加をクリック
    - URL に 今設定したURLが表示されていることを確認
    - 必要なら名前を設定
    - 完了をクリック
- トリガとなるノードを接続
- デプロイする

# クライアント側でWebsocketでデータを受信する

- パレットの「入力」の下の「websocket」 をフローにドラッグ&ドロップ
- ドロップした「websocket」をダブルクリック → 編集メニューが表示される
    - 種類で「接続」を選択
    - URL で 「新規に websocket-client を追加」を選択してその右の編集ボタンをクリック or 既に設定されているサーバを選択
        - URL でサーバのURLを設定(例： ws://PiDev25.local:1880/ws/data01)
        - 追加をクリック
    - 必要なら名前を設定
    - 完了をクリック
- 受信したメッセージを処理するノードを接続
- デプロイする

# RaspberryPiでGPIO出力

- パレットの「Raspberry Pi」の下の「rpi gpio」(出力ノードの方) をフローにドラッグ&ドロップ
- ドロップした「PIN」をダブルクリック → 編集メニューが表示される
    - 「端子」で出力する端子を選択
    - 「出力形式」で「デジタル出力」を選択
    - デプロイしたときに端子状態を初期化したい場合は「端子の状態を初期化」をチェック
    - 「端子の初期状態レベル」を選択
    - 必要なら「名前」を設定
    - 完了をクリック
- トリガとなるノードを接続
- デプロイする

# RaspberryPiでGPIO入力

- パレットの「Raspberry Pi」の下の「rpi gpio」(入力ノードの方) をフローにドラッグ&ドロップ
- ドロップした「PIN」をダブルクリック → 編集メニューが表示される
    - 「端子」で入力する端子を選択
    - 「抵抗」で端子に接続されたプルアップ/ダウン種別を選択(端子の初期化時に内部のプルアップ/ダウン抵抗のどちらを有効にするかを選択。ボード上で処理してれば「なし」を選ぶ)
    - デバウンスにチャタリング除去時間を設定
    - デプロイしたときに端子状態を読み込みたい場合は「～初期状態を読み込む」をチェック
    - 必要なら「名前」を設定
    - 完了をクリック
- 入力信号を処理するノードを接続
- デプロイする

# RaspberryPiでI2Cを使用する

## 事前準備

- I2Cを有効化する(リブートは不要らしい)
```bash
sudo raspi-config
    5 Interfacing Options
        P5 I2C
            Would you like the ARM I2C interface to be enabled?
            に対して<はい>を選択
            The ARM I2C interface is enabled
            と表示されるので<了解>
    <Finish>
```
- I2Cデバイスアクセス用ツールをインストールする
```bash
sudo apt install i2c-tools
```
- i2cバスをスキャンしてみる(RasbberryPi2/3のI2Cバスはバス1が出てる。古いのだと0のもあるらしい)
```bash
i2cdetect -y 1
```
```bash
#   ↓結果(例)
    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- 13 -- -- -- -- -- 19 -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- 69 -- -- -- -- -- --
70: -- -- -- -- -- -- 76 --
# 76がBME280(Bosch温湿度センサ)
```
- I2Cデバイスのレジスタをリードしてみる    
```bash
i2cget -y 1 0x76 0xd0
```
```bash
# ↓ 結果
0x60
# レジスタ 0xd0(CHIP ID)をリードするとデバイスのID 0x60が読める
```

## BME280用ノードをインストールする
- ブラウザでNode-REDに接続した状態で、右上の3本線メニュー(≡) から「パレットの管理」をクリック
- 画面上部の「ノードを追加」をクリック
- ノードを検索の部分に「bme280」と入力
- 下に検索結果が出るので。「node-red-contrib-bme280」の「ノードを追加」をクリック
- 何やらダイアログが出るので、「追加」をクリック
- 完了したら「閉じる」をクリック。

## BME280を使用するフローを作成する
- パレットの「入力」の下の「Bme280」 をフローにドラッグ&ドロップ
- ドロップした「Bme280」をダブルクリック → 編集メニューが表示される
    - 必要ならNameにノード名を設定
    - Bus# にバス番号(1)を設定
    - I2C Address にI2Cアドレス(0x76)を設定
    - Topicが必要なら設定(デフォルトはbme280)
    - 右上の「完了」をクリック
- トリガとなるノードを入力側に接続
- 信号を処理するノードを出力側に接続  
- デプロイする

Bme280ノードの出力メッセージの内容は以下の通り  

|変数名                     |値の例              |項目      |
|---                        |---                 |---       |
| msg.topic                 | "bme280"           | ノードの設定で設定したTopic |
| msg.payload.temperature_C | 34.23              | 温度     |
| msg.payload.humidity      | 54.402349427117336 | 湿度     | 
| msg.payload.pressure_hPa  | 1013.9016246356634 | 気圧     |
| msg.payload.model         | "BME280"           | センサ名 | 

## BME280データをWebsocketで送信する

**BME280を使用するフローを作成する**で作成したノードを
**サーバ側でWebsocketでデータを送信する**/**クライアント側でWebsocketでデータを送信する**の手順で作成したノードに接続すれば良い。  
このとき、送信されるデータはmsg.payloadなので、文字列ではなく、object。  
(WebsocketのパケットにはobjectをJSON文字列化したものが入る)

## WebsocketからBME280データを受信する

**サーバ側でWebsocketでデータを受信する**/**クライアント側でWebsocketでデータを受信する**の手順で作成したノードから処理するノードに接続すれば良い。  
このとき、mag.payloadはJSON文字列なので、objectに変換してやらないと使用できない。  
そのため、Websocketのノードの出力をjsonノードで変換してやる必要がある。  

- パレットの「機能」の下の「json」 をフローにドラッグ&ドロップ
- ドロップした「json」をダブルクリック → 編集メニューが表示される
    - 動作で「常にJavascriptオブジェクトに変換」を選択
    - プロパティは「msg.payload」を設定(デフォルトのまま)
    - 必要なら名前にノード名を設定
    - 右上の「完了」をクリック
- Websocketのノードを入力側に接続

jsonノードから出力されるデータのpayloadはobjectなので、受け取るノードがpayloadが値や文字列でないといけない場合に一旦functionノードで変換する必要がある。  
(受け取るノードがobjectを処理するなら必要ない)  

- パレットの「機能」の下の「function」 をフローにドラッグ&ドロップ
- ドロップした「function」をダブルクリック → 編集メニューが表示される
    - 必要なら名前にノード名を設定
    - コードを設定(下記参照)  
    - 出力数に「3」を設定
    - 右上の「完了」をクリック。
- これでfunctionノードの出力端子が3個になり、上から温度、湿度、気圧データが出力される。

```bash
// make deep copy
var msg_temp  = JSON.parse(JSON.stringify(msg));
var msg_hum   = JSON.parse(JSON.stringify(msg));
var msg_press = JSON.parse(JSON.stringify(msg));

msg_temp.topic    = "temperature_C";
msg_temp.payload  = msg.payload.temperature_C;
msg_hum.topic     = "humidity";
msg_hum.payload   = msg.payload.humidity;
msg_press.topic   = "pressure_hPa";
msg_press.payload = msg.payload.pressure_hPa;

return [msg_temp, msg_hum, msg_press];
```

注意点として、``var msg_temp  = msg;``などとしてはいけない。  
この場合、``msg_temp``は``msg``の浅いコピーとなってしまうため、その下で``msg_temp.payload``を変更すると、``msg.payload``も変更されてしまうことになる。  
これを防ぐため、深いコピーを作成している。これには``msg``をJSON文字列化して、再度パースすることで対応している。  

なお、フローエディタ上でどの端子がどの信号か分からなくなるのを防ぐため、端子に名前を付けることができる。  
(付けなくても動作上は問題ない)  

- 「function」ノードをダブルクリック → 編集メニューが表示される
    - 右上の「完了」ボタンの下にある「外観」ボタン(ウィンドウ表示のアイコン)をクリック
    - ポートラベルの下の出力の下、1、2、3に対して、それぞれ分かりやすい名前を付ける
    - 右上の「完了」をクリック

- 信号を処理するノードを出力側に接続  
- デプロイする


## Websocketから受信したBME280データをDashboardでゲージグラフ表示する

上記で受信したBME280のデータをゲDashboardを使用してゲージグラフ(メータグラフ)で表示します。  
上記手順でDashboardはインストール済みであるものとします。  

- パレットの「dashboard」の下の「guage」 をフローにドラッグ&ドロップ
- ドロップした「guage」をダブルクリック → 編集メニューが表示される
    - Group でゲージグラフを登録するグループを選択。新たにグループを追加する場合は上記『Dashboard のフローを作成する』を参照
    - Size は自動のままでも、表示したいサイズを選んでも良い
    - Type でグラフの種類を選ぶ。温度/湿度/気圧ならguageが良いでしょう。お好みで
    - Label でグラフのタイトルを指定する。「温度」など
    - Value format でグラフに表示する値を指定する。デフォルトの``{% raw %}{{value}}{% endraw %}``では受信したデータのpayload(``msg.payload`` )を使用します。  
      このとき、``{% raw %}{{{% endraw %}`` と ``{% raw %}}}{% endraw %}`` は波括弧を2つ重ねたものです。波括弧1つだと正常に処理できませんので、注意してください。  
       ただ、このままだと、数値表示の有効桁が大きくなるため、以下のようにフィルタを設定して四捨五入します。  
       例えば、小数点以下1桁まで表示したい場合は、``{% raw %}{{value | number:1 }}{% endraw %}``のように指定します。  
       同様に1の位までの場合は`` number:0``、10の位までの場合は`` number:-1``と指定します。  
      また、単位を表示するなど、決まった文字列を追加したい場合は「``{% raw %}{{・・・}}℃{% endraw %}``」のように波括弧の外側に追加してください。  
    - units で単位を設定する。温度なら「℃」など。これは数値表示には表示されず、グラフ内部の単位情報として表示されます。
    - Range でグラフの値の範囲を指定する。温度なら「-20」～「40」など。入力値が範囲外になった場合はグラフが上下限に張り付くだけで、エラーなどにはならない。また値そのものは数値表示される  
    - Colour gradient でグラフの色を指定する。3つの色は下で設定するSectors の範囲に対応する
    - Sectors で 上で指定した色を表示する範囲を設定する。これはオプションなので設定しなくても良い。指定しなかった場合は上のRangeで指定した値の範囲を3等分して使用される
    - 必要ならNameにノード名を設定。省略するとLabelに設定した値が使用される
    - 右上の「完了」をクリック

- 上記で作成したBME280データを処理するfunctionノードの出力と接続する
- デプロイする

これでDashboardを表示して、BME280のデータを送信すればゲージグラフに反映される。  



## Websocketから受信したBME280データをDashboardでゲージグラフ表示する(その2)

実は、上記方法以外にWebsocketから受信したBME280データをグラフ表示することができます。  
この方法ではBME280データを処理するfunctionノードを省略することができます。  

基本は上記『Websocketから受信したBME280データをDashboardでゲージグラフ表示する』と同じですが、以下の部分を変更します。  
 - Value format でグラフに表示する値を指定する。温度を表示する場合、``{% raw %}{{msg.payload.temperature_C}}{% endraw %}`` を指定する。  
   同様に湿度の場合は``{% raw %}{{msg.payload.humidity}}{% endraw %}``を、気圧の場合は``{% raw %}{{msg.payload.pressure_hPa}}{% endraw %}``をそれぞれ指定する。  
   ただ、このままだと、数値表示の有効桁が大きくなるため、以下のようにフィルタを設定して四捨五入します。  
   例えば、温度を小数点以下1桁まで表示したい場合は、``{% raw %}{{msg.payload.temperature_C | number:1 }}{% endraw %}``のように指定します。  
   同様に1の位までの場合は`` number:0``、10の位までの場合は`` number:-1``と指定します。  

- 上記で作成したjsonノードの出力と接続する  
  jsonノードは省略できません

>[!WARNING]
>これで理屈的には大丈夫なハズなんだけど、``{% raw %}{{msg.payload.pressure_hPa}}{% endraw %}``を指定すると、値は正常に表示されるけど、グラフが正常に表示されない。。。  
``{% raw %}{{msg.payload.humidity}}{% endraw %}``は大丈夫。  
ナゼだ？？  
【追記】  
どうやら、この形で指定すると、値が1000を超えるとグラフ表示がおかしくなるようだ。バグか？  
とりあえず、functionノードを噛ませて値をバラした方が安心なようだ。  

>[!NOTE]
> Value typeの詳細は<https://scotch.io/tutorials/all-about-the-built-in-angularjs-filters>を見ろと書かれていましたが、残念ながら私にはよく分かりませんでした...  



